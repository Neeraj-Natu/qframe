// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package iseries

import (
	"fmt"

	"github.com/tobgu/qframe/internal/index"
	"github.com/tobgu/qframe/internal/series"
)

// Code generated from template/series.go DO NOT EDIT

type Series struct {
	data []int
}

func New(d []int) Series {
	return Series{data: d}
}

// Apply single argument function. The result may be a column
// of a different type than the current series.
func (s Series) Apply1(fn interface{}, ix index.Int) (interface{}, error) {
	var err error
	switch t := fn.(type) {
	case func(int) (int, error):
		result := make([]int, len(s.data))
		for _, i := range ix {
			if result[i], err = t(s.data[i]); err != nil {
				return nil, err
			}
		}
		return result, nil
	case func(int) (float64, error):
		result := make([]float64, len(s.data))
		for _, i := range ix {
			if result[i], err = t(s.data[i]); err != nil {
				return Series{}, err
			}
		}
		return result, nil
	case func(int) (bool, error):
		result := make([]bool, len(s.data))
		for _, i := range ix {
			if result[i], err = t(s.data[i]); err != nil {
				return Series{}, err
			}
		}
		return result, nil
	case func(int) (*string, error):
		result := make([]*string, len(s.data))
		for _, i := range ix {
			if result[i], err = t(s.data[i]); err != nil {
				return Series{}, err
			}
		}
		return result, nil
	default:
		return nil, fmt.Errorf("cannot apply type %#v to column", fn)
	}
}

// Apply double argument function to two columns. Both columns must have the
// same type. The resulting series will have the same type as this series.
func (s Series) Apply2(fn interface{}, s2 series.Series, ix index.Int) (series.Series, error) {
	ss2, ok := s2.(Series)
	if !ok {
		return Series{}, fmt.Errorf("Apply2: invalid series type: %#v", s2)
	}

	t, ok := fn.(func(int, int) (int, error))
	if !ok {
		return Series{}, fmt.Errorf("Apply2: invalid function type: %#v", fn)
	}

	result := make([]int, len(s.data))
	var err error
	for _, i := range ix {
		if result[i], err = t(s.data[i], ss2.data[i]); err != nil {
			return Series{}, err
		}
	}

	return New(result), nil
}

func (s Series) subset(index index.Int) Series {
	data := make([]int, len(index))
	for i, ix := range index {
		data[i] = s.data[ix]
	}

	return Series{data: data}
}

func (s Series) Subset(index index.Int) series.Series {
	return s.subset(index)
}

func (s Series) Comparable(reverse bool) series.Comparable {
	if reverse {
		return Comparable{data: s.data, ltValue: series.GreaterThan, gtValue: series.LessThan}
	}

	return Comparable{data: s.data, ltValue: series.LessThan, gtValue: series.GreaterThan}
}

func (s Series) String() string {
	return fmt.Sprintf("%v", s.data)
}

func (s Series) Aggregate(indices []index.Int, fn interface{}) (series.Series, error) {
	var actualFn func([]int) int
	var ok bool

	switch t := fn.(type) {
	case string:
		actualFn, ok = aggregations[t]
		if !ok {
			return nil, fmt.Errorf("aggregation function %s is not defined for series", fn)
		}
	case func([]int) int:
		actualFn = t
	default:
		// TODO: Genny is buggy and won't let you use your own errors package.
		//       We use a standard error here for now.
		return nil, fmt.Errorf("invalid aggregation function type: %v", t)
	}

	data := make([]int, 0, len(indices))
	for _, ix := range indices {
		subS := s.subset(ix)
		data = append(data, actualFn(subS.data))
	}

	return Series{data: data}, nil
}

type Comparable struct {
	data    []int
	ltValue series.CompareResult
	gtValue series.CompareResult
}
